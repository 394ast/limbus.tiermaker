<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>みんなでつくる　リンバスTier表</title>
    <style>
      body { font-family: sans-serif; margin: 24px; }
      .grid-line { margin: 8px 0 12px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
      .indent { font-weight: 600; }
      #imgSizeForm input[type="number"] { width: 72px; }
      .sync-mode { margin: 8px 0 12px; }
      .sync-mode label { margin-right: 12px; }
      .scroll-fix-options { margin: 8px 0 12px; }
      .scroll-fix-options label { margin-right: 12px; }
      .id-range-filters { margin: 8px 0 12px; border: 1px solid #d7d7d7; border-radius: 4px; padding: 4px 6px; width: fit-content; max-width: 100%; }
      .id-range-group { margin-bottom: 8px; }
      .id-range-title { font-weight: 600; margin: 0 0 4px; }
      .id-range-options { display: flex; flex-wrap: wrap; gap: 4px 12px; }
      .id-range-subgroup { width: 100%; }
      .id-range-filter { font-size: 12px; white-space: nowrap; }
      .id-range-actions { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 4px; }
      table { border-collapse: collapse; width: 100%; max-width: none; margin-bottom: 20px; }
      th, td { border: 1px solid #ccc; padding: 6px 8px; text-align: right; }
      th:first-child, td:first-child { text-align: center; max-width: 20px; width: 20px; }
      th:nth-child(2), td:nth-child(2) { text-align: left; }
      .tier-label { font-weight: 700; }
      .tier-ss { background-color: #f0c7c7; }
      .tier-s-plus { background-color: #f1d0c5; }
      .tier-s { background-color: #f1dcc9; }
      .tier-s-minus { background-color: #eee8cd; }
      .tier-a { background-color: #e2edcf; }
      .tier-b { background-color: #d5eade; }
      .tier-c { background-color: #d0e6ee; }
      .tier-d { background-color: #ccddf0; }
      .tier-e { background-color: #c8d4ee; }
      .tier-except { background-color: #ececec; color: #555; }
      .error { color: #b00020; }
      .id-items { display: flex; flex-wrap: wrap; gap: 2px; justify-content: flex-start; }
      .id-item { display: flex; align-items: center; gap: 6px; border: 1px solid #ddd; border-radius: 4px; padding: 2px; background: #fff; }
      .id-item img { width: var(--img-size, 56px); height: var(--img-size, 56px); object-fit: cover; border-radius: 4px; border: 1px solid #ddd; }
      .id-main { display: grid; gap: 2px; justify-items: center; }
      .id-name { font-size: 13px; line-height: 1.2; text-align: center; word-break: break-word; }
      .id-name-primary { white-space: nowrap; word-break: normal; }
      .id-controls { display: flex; flex-direction: column; align-items: stretch; gap: 4px; }
      .id-controls button:disabled { opacity: 0.4; cursor: not-allowed; }
      .id-controls label { font-size: 12px; }
      .hide-adjust-controls .id-controls { display: none; }
      .share-url-tools { margin: 8px 0 12px; display: grid; gap: 6px; }
      #generateUrlButton { width: fit-content; font-size: 13px; padding: 4px 10px; }
      .hide-except-move-controls button[data-action="toggle-except"][data-include="0"] { display: none; }
      #generatedUrl { width: 100%; max-width: 900px; resize: vertical; white-space: pre-wrap; word-break: break-all; overflow-wrap: anywhere; line-height: 1.35; min-height: 3.2em; }
      #generatedUrl.dynamic-width { width: min(98vw, var(--generated-url-width, 900px)); }
      #hiddenPrisonerDialog { width: min(520px, calc(100vw - 32px)); border: none; border-radius: 8px; padding: 16px; box-shadow: 0 10px 24px rgba(0, 0, 0, 0.24); }
      #hiddenPrisonerDialog::backdrop { background: rgba(0, 0, 0, 0.45); }
      .hidden-prisoner-title { margin: 0 0 12px; font-size: 18px; }
      .hidden-prisoner-actions { display: grid; gap: 8px; }
      .hidden-prisoner-actions button { font-size: 14px; padding: 7px 10px; text-align: left; }
      #openLatestTierButton { margin: 4px 0 12px; font-size: 13px; padding: 4px 10px; }
    </style>
</head>
<body>
  <h2>みんなでつくる　リンバスTier表</h2>
  <button type="button" id="openLatestTierButton">現在のみんなでつくったTier表を表示</button>

  <div id="status" aria-live="polite" hidden></div>

  

  <div class="grid-line">
    <span class="indent">画像のサイズ:</span><div id="imgSizeForm">
      <input type="radio" name="imgSize" value="size1">小
      <input type="radio" name="imgSize" value="size2">中
      <input type="radio" name="imgSize" value="size3" checked>大
      <input type="radio" name="imgSize" value="size4">特大<br>
      <input type="radio" name="imgSize" value="custom">カスタム <input type="number" id="customWidth" disabled>px
    </div>
  </div>

  <div class="sync-mode">
    <span class="indent">人格の画像:</span>
    <label><input type="radio" name="syncMode" value="before"> 同期前</label>
    <label><input type="radio" name="syncMode" value="after" checked> 同期後</label>
  </div>

  <div class="sync-mode">
    <label><input type="checkbox" id="toggleAdjustControls" checked> Tierの移動ボタンを表示する</label>
  </div>
  <div class="sync-mode">
    <label><input type="checkbox" id="toggleExceptMoveControls" checked> 除外ランクへの移動ボタンを表示する</label>
  </div>
  <div class="sync-mode">
    <label><input type="checkbox" id="toggleExceptRows" checked> 除外ランクを表示する</label>
  </div>
  <div class="sync-mode">
    <label><input type="checkbox" id="toggleName1"> 人格,E.G.O.名を表示する</label>
    <label><input type="checkbox" id="toggleName2"> 囚人名を表示する</label>
  </div>

  <div class="scroll-fix-options">
    <span class="indent">Tierの移動ボタンを押した後のカーソルの位置:</span>
    <label><input type="radio" name="scrollFixMode" value="group-relative" checked> 移動前のランク</label>
    <label><input type="radio" name="scrollFixMode" value="item-delta"> 移動後のランク</label>
  </div>

  <div id="idRangeFilters" class="id-range-filters"></div>

  <div class="share-url-tools">
    <button type="button" id="generateUrlButton">URLを生成する</button>
    <textarea id="generatedUrl" readonly rows="2" placeholder="生成されたURLがここに表示されます"></textarea>
  </div>

  <dialog id="hiddenPrisonerDialog">
    <h3 class="hidden-prisoner-title">非表示状態になっている囚人がいます</h3>
    <div class="hidden-prisoner-actions">
      <button type="button" data-action="show-and-generate">非表示状態の囚人を表示してURLを生成</button>
      <button type="button" data-action="except-and-generate">非表示状態の囚人を除外ランクに移動してURLを生成</button>
      <button type="button" data-action="cancel-generate">URLの生成をキャンセル</button>
    </div>
  </dialog>

  <h3>人格Tier</h3>
  <table>
    <tbody id="resultBodyIdentity"></tbody>
  </table>

  <h3>E.G.O.Tier</h3>
  <table>
    <tbody id="resultBodyEgo"></tbody>
  </table>

  <script>
    const statusEl = document.getElementById('status');
    const bodyIdentityEl = document.getElementById('resultBodyIdentity');
    const bodyEgoEl = document.getElementById('resultBodyEgo');
    const syncModeInputs = document.querySelectorAll('input[name="syncMode"]');
    const imgSizeForm = document.getElementById('imgSizeForm');
    const customWidthInput = document.getElementById('customWidth');
    const toggleAdjustControlsInput = document.getElementById('toggleAdjustControls');
    const toggleExceptRowsInput = document.getElementById('toggleExceptRows');
    const toggleName1Input = document.getElementById('toggleName1');
    const toggleName2Input = document.getElementById('toggleName2');
    const toggleExceptMoveControlsInput = document.getElementById('toggleExceptMoveControls');
    const idRangeFiltersEl = document.getElementById('idRangeFilters');
    const generateUrlButton = document.getElementById('generateUrlButton');
    const generatedUrlInput = document.getElementById('generatedUrl');
    const openLatestTierButton = document.getElementById('openLatestTierButton');
    const hiddenPrisonerDialog = document.getElementById('hiddenPrisonerDialog');
    const scrollFixModeInputs = document.querySelectorAll('input[name="scrollFixMode"]');

    const state = {
      tierlist: null,
      x: null,
      tableIndex: 0,
      manualGroupById: new Map(),
      exceptIdentityIds: new Set(),
      exceptEgoIds: new Set(),
      exceptRestoreGroupById: new Map(),
      baseGroupedByType: {
        identity: null,
        ego: null,
      },
      baseGroupedSnapshot: {
        tierlist: null,
        x: null,
      },
      baseValueById: new Map(),
      nameDataById: new Map(),
      idMetaById: new Map(),
      changeParam: null,
      scrollFixMode: 'group-relative',
    };

    const GROUP_META = {
      9: { label: 'SS', className: 'tier-ss' },
      8: { label: 'S+', className: 'tier-s-plus' },
      7: { label: 'S', className: 'tier-s' },
      6: { label: 'S-', className: 'tier-s-minus' },
      5: { label: 'A', className: 'tier-a' },
      4: { label: 'B', className: 'tier-b' },
      3: { label: 'C', className: 'tier-c' },
      2: { label: 'D', className: 'tier-d' },
      1: { label: 'E', className: 'tier-e' },
      0: { label: '除外', className: 'tier-except' },
    };

    const GENERATED_URL_BASE_WIDTH_PX = 900;
    const GENERATED_URL_BASE_ROWS = 2;
    const changecodingDIffID = 0; // 下位idが36を超えるとき手動で1に変更する


    function calcValue(row, x) {
      const numerator = row[1] + 0.01 * x * row[3];
      const denominator = row[2] + 0.01 * x * row[4];
      return denominator === 0 ? NaN : numerator / denominator;
    }

    function belongsToType(id, type) {
      return type === 'identity' ? id < 13001 : id >= 13001;
    }

    function getExceptSet(type) {
      return type === 'identity' ? state.exceptIdentityIds : state.exceptEgoIds;
    }

    function buildGroupedData(rows, x) {
      const grouped = new Map();
      const idToGroup = new Map();

      for (let group = 9; group >= 0; group -= 1) {
        grouped.set(group, []);
      }

      rows.forEach((row) => {
        const id = row[0];
        const value = calcValue(row, x);

        if (!Number.isFinite(value)) {
          throw new Error(`ID ${id} の計算結果が不正です。`);
        }

        if (value < 1 || value > 9) {
          throw new Error(`ID ${id} の計算結果が範囲外です: ${value}（1以上9以下である必要があります）`);
        }

        const rounded = Math.round(value);

        if (!grouped.has(rounded)) {
          throw new Error(`ID ${id} の丸め後グループが範囲外です: ${rounded}`);
        }

        grouped.get(rounded).push(id);
        idToGroup.set(id, rounded);
      });

      return { grouped, idToGroup };
    }


    function cloneGroupedData(baseData) {
      const grouped = new Map();
      baseData.grouped.forEach((ids, groupValue) => {
        grouped.set(groupValue, [...ids]);
      });

      return {
        grouped,
        idToGroup: new Map(baseData.idToGroup),
      };
    }

    function initializeBaseGroupedData(tierlist, x) {
      const identityRows = [];
      const egoRows = [];
      const baseValueById = new Map();

      tierlist.forEach((row) => {
        const id = row[0];
        baseValueById.set(id, calcValue(row, x));

        if (id < 13001) {
          identityRows.push(row);
          return;
        }

        egoRows.push(row);
      });

      state.baseGroupedByType.identity = buildGroupedData(identityRows, x);
      state.baseGroupedByType.ego = buildGroupedData(egoRows, x);
      state.baseGroupedSnapshot.tierlist = tierlist;
      state.baseGroupedSnapshot.x = x;
      state.baseValueById = baseValueById;
    }

    function getBaseGroupForId(type, id) {
      const baseData = state.baseGroupedByType[type];
      if (!baseData) {
        return null;
      }

      const baseGroup = baseData.idToGroup.get(id);
      return Number.isInteger(baseGroup) ? baseGroup : null;
    }

    function setManualGroupOverride(id, type, targetGroup) {
      const baseGroup = getBaseGroupForId(type, id);
      if (baseGroup !== null && targetGroup === baseGroup) {
        state.manualGroupById.delete(id);
        return;
      }

      state.manualGroupById.set(id, targetGroup);
    }

    function resetDiffState() {
      state.manualGroupById.clear();
      state.exceptIdentityIds.clear();
      state.exceptEgoIds.clear();
      state.exceptRestoreGroupById.clear();
    }

    function moveIdBetweenGroups(grouped, idToGroup, id, targetGroup) {
      const fromGroup = idToGroup.get(id);

      if (!Number.isInteger(fromGroup) || !grouped.has(fromGroup) || !grouped.has(targetGroup)) {
        return;
      }

      if (fromGroup === targetGroup) {
        return;
      }

      grouped.set(fromGroup, grouped.get(fromGroup).filter((currentId) => currentId !== id));
      grouped.get(targetGroup).push(id);
      idToGroup.set(id, targetGroup);
    }

    function applyManualAndExceptOverrides(grouped, idToGroup, type) {
      state.manualGroupById.forEach((targetGroup, id) => {
        if (!belongsToType(id, type)) {
          return;
        }

        if (!idToGroup.has(id) || targetGroup < 1 || targetGroup > 9) {
          return;
        }

        moveIdBetweenGroups(grouped, idToGroup, id, targetGroup);
      });

      const exceptIds = getExceptSet(type);
      exceptIds.forEach((id) => {
        if (!idToGroup.has(id)) {
          return;
        }

        moveIdBetweenGroups(grouped, idToGroup, id, 0);
      });
    }

    function getIdentityImageUrl(id) {
      const checked = document.querySelector('input[name="syncMode"]:checked');
      const syncMode = checked ? checked.value : 'before';

      if (syncMode === 'after') {
        return `https://raw.githubusercontent.com/394ast/limbus.sharetool/main/Identities.After/${id}.3.jpg`;
      }

      return `https://raw.githubusercontent.com/394ast/limbus.sharetool/main/Identities.Before/${id}.1.jpg`;
    }

    function getEgoImageUrl(id) {
      return `https://raw.githubusercontent.com/394ast/limbus.sharetool/main/EGO/${id}.jpg`;
    }

    function escapeHtml(text) {
      return String(text)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function getDisplayNames(id) {
      const nameData = state.nameDataById.get(id);
      if (!nameData) {
        return { name1: '', name2: '' };
      }

      const name1 = typeof nameData.name1 === 'string' ? nameData.name1 : '';
      const name2 = typeof nameData.name2 === 'string' ? nameData.name2 : '';
      return { name1, name2 };
    }

    function renderControlButtons(id, groupValue, isExcept, type) {
      if (isExcept) {
        return `<button type="button" data-action="toggle-except" data-include="1" data-id="${id}" data-type="${type}" data-group="${groupValue}">戻す</button>`;
      }

      const disablePlus2 = groupValue >= 8;
      const disablePlus1 = groupValue >= 9;
      const disableMinus1 = groupValue <= 1;
      const disableMinus2 = groupValue <= 2;

      return [
        `<button type="button" data-action="move" data-delta="2" data-id="${id}" data-type="${type}" data-group="${groupValue}" ${disablePlus2 ? 'disabled' : ''}>+2</button>`,
        `<button type="button" data-action="move" data-delta="1" data-id="${id}" data-type="${type}" data-group="${groupValue}" ${disablePlus1 ? 'disabled' : ''}>+1</button>`,
        `<button type="button" data-action="toggle-except" data-include="0" data-id="${id}" data-type="${type}" data-group="${groupValue}">除外</button>`,
        `<button type="button" data-action="move" data-delta="-1" data-id="${id}" data-type="${type}" data-group="${groupValue}" ${disableMinus1 ? 'disabled' : ''}>-1</button>`,
        `<button type="button" data-action="move" data-delta="-2" data-id="${id}" data-type="${type}" data-group="${groupValue}" ${disableMinus2 ? 'disabled' : ''}> -2</button>`
      ].join('');
    }

    function renderImageCells(ids, groupValue, type) {
      const isExcept = groupValue === 0;

      const items = ids.map((id) => {
        const src = type === 'identity' ? getIdentityImageUrl(id) : getEgoImageUrl(id);
        const { name1, name2 } = getDisplayNames(id);
        const showName1 = Boolean(toggleName1Input?.checked && name1);
        const showName2 = Boolean(toggleName2Input?.checked && name2);

        return `
          <div class="id-item">
            <div class="id-main">
              <img src="${src}" alt="${id}" loading="lazy">
              ${showName1 ? `<div class="id-name id-name-primary">${escapeHtml(name1)}</div>` : ''}
              ${showName2 ? `<div class="id-name">${escapeHtml(name2)}</div>` : ''}
            </div>
            <div class="id-controls">
              ${renderControlButtons(id, groupValue, isExcept, type)}
            </div>
          </div>
        `;
      }).join('');

      return `<div class="id-items">${items}</div>`;
    }

    function getGroupLabel(groupValue) {
      return GROUP_META[groupValue]?.label ?? String(groupValue);
    }

    function getGroupClass(groupValue) {
      return GROUP_META[groupValue]?.className ?? '';
    }

    function getIdRangeFilters() {
      const displayNames = [
        'イサン', 'ファウスト', 'ドンキホーテ', '良秀', 'ムルソー', 'ホンル',
        'ヒースクリフ', 'イシュメール', 'ロージャ', 'シンクレア', 'ウーティス', 'グレゴール'
      ];

      const identity = displayNames.map((name, i) => ({ bucket: i + 1, name }));
      const ego = displayNames.map((name, i) => ({ bucket: i + 13, name }));

      return { identity, ego };
    }

    function renderIdRangeFilters() {
      if (!idRangeFiltersEl) {
        return;
      }

      const { identity, ego } = getIdRangeFilters();
      const seasonOptions = [
        { key: '恒常', label: '恒常' },
        { key: 'SEASON 1', label: 'SEASON 1' },
        { key: 'SEASON 2', label: 'SEASON 2' },
        { key: 'SEASON 3', label: 'SEASON 3' },
        { key: 'SEASON 4', label: 'SEASON 4' },
        { key: 'SEASON 5', label: 'SEASON 5' },
        { key: 'SEASON 6', label: 'SEASON 6' },
        { key: 'SEASON 7', label: 'SEASON 7' },
        { key: 'WALPURGISNACHT', label: 'WALPURGISNACHT' },
        { key: 'COLLABORATION-LIMITED', label: 'COLLABORATION-LIMITED' },
      ];
      const identityRankOptions = [1, 2, 3].map((rank) => ({ key: `i-${rank}`, label: `人格 ${rank}` }));
      const egoRankOptions = [1, 2, 3, 4, 5].map((rank) => ({ key: `e-${rank}`, label: `E.G.O. ${rank}` }));
      const timeOptions = [
        { key: '0,1', label: '0,1' },
        { key: '2', label: '2' },
        { key: '3', label: '3' },
        { key: '4', label: '4' },
        { key: '5', label: '5' },
        { key: '6', label: '6' },
        { key: '7', label: '7' },
      ];

      const renderOptions = (items, filterType) => items.map((item) => {
        const key = filterType === 'bucket' ? item.bucket : item.key;
        const label = filterType === 'bucket' ? item.name : item.label;
        return `<label class="id-range-filter"><input type="checkbox" data-action="toggle-id-range" data-filter-type="${filterType}" data-key="${key}" checked> ${label}</label>`;
      }).join('');

      const renderGroupActions = () => '<div class="id-range-actions"><button type="button" data-action="clear-group-ranges">全解除</button><button type="button" data-action="check-group-ranges">全表示</button></div>';

      idRangeFiltersEl.innerHTML = [
        `<div class="id-range-group"><p class="id-range-title">表示する人格</p><div class="id-range-options">${renderOptions(identity, 'bucket')}</div>${renderGroupActions()}</div>`,
        `<div class="id-range-group"><p class="id-range-title">表示するE.G.O.</p><div class="id-range-options">${renderOptions(ego, 'bucket')}</div>${renderGroupActions()}</div>`,
        `<div class="id-range-group"><p class="id-range-title">区分</p><div class="id-range-options">${renderOptions(seasonOptions, 'season')}</div>${renderGroupActions()}</div>`,
        `<div class="id-range-group"><p class="id-range-title">rank</p><div class="id-range-options"><div class="id-range-subgroup"><span class="id-range-filter">人格のrank</span><div class="id-range-options">${renderOptions(identityRankOptions, 'rank')}</div>${renderGroupActions()}</div><div class="id-range-subgroup"><span class="id-range-filter">E.G.Oのrank</span><div class="id-range-options">${renderOptions(egoRankOptions, 'rank')}</div>${renderGroupActions()}</div></div></div>`,
        `<div class="id-range-group"><p class="id-range-title">実装時期</p><div class="id-range-options">${renderOptions(timeOptions, 'time')}</div>${renderGroupActions()}</div>`
      ].join('');
    }

    function setRangeFiltersInContainer(container, checked) {
      if (!container) {
        return;
      }

      const checkboxes = container.querySelectorAll('input[data-action="toggle-id-range"]');
      checkboxes.forEach((checkbox) => {
        checkbox.checked = checked;
      });

      clearGeneratedUrl();

      if (state.tierlist && Number.isFinite(state.x)) {
        renderRows(state.tierlist, state.x);
      }
    }


    function setAllRangeFilters(checked) {
      setRangeFiltersInContainer(idRangeFiltersEl, checked);
    }

    function getActiveFilterKeys(filterType) {
      if (!idRangeFiltersEl) {
        return null;
      }

      const selected = new Set();
      const checkboxes = idRangeFiltersEl.querySelectorAll(`input[data-action="toggle-id-range"][data-filter-type="${filterType}"]:checked`);
      checkboxes.forEach((checkbox) => {
        const key = checkbox.dataset.key;
        if (typeof key === 'string' && key !== '') {
          selected.add(key);
        }
      });

      return selected;
    }

    function hasUncheckedRangeFilters() {
      if (!idRangeFiltersEl) {
        return false;
      }

      const checkboxes = idRangeFiltersEl.querySelectorAll('input[data-action="toggle-id-range"]');
      return Array.from(checkboxes).some((checkbox) => !checkbox.checked);
    }

    function getHiddenPrisonerIds() {
      if (!state.tierlist) {
        return [];
      }

      const filters = {
        buckets: getActiveFilterKeys('bucket'),
        seasons: getActiveFilterKeys('season'),
        ranks: getActiveFilterKeys('rank'),
        times: getActiveFilterKeys('time'),
      };

      if (!filters.buckets || !filters.seasons || !filters.ranks || !filters.times) {
        return [];
      }

      return state.tierlist
        .map((row) => row[0])
        .filter((id) => !isIdVisibleByFilters(id, filters));
    }

    function getCurrentGroupOfId(id, type) {
      if (getExceptSet(type).has(id)) {
        return 0;
      }

      const manualGroup = state.manualGroupById.get(id);
      if (Number.isInteger(manualGroup)) {
        return manualGroup;
      }

      return getBaseGroupForId(type, id);
    }

    function moveIdsToExcept(ids) {
      ids.forEach((id) => {
        const type = belongsToType(id, 'identity') ? 'identity' : 'ego';
        const exceptSet = getExceptSet(type);
        const currentGroup = getCurrentGroupOfId(id, type);

        if (!exceptSet.has(id) && Number.isInteger(currentGroup) && currentGroup > 0) {
          state.exceptRestoreGroupById.set(id, currentGroup);
        }

        exceptSet.add(id);
      });
    }

    function promptHiddenPrisonerChoice() {
      if (!hiddenPrisonerDialog || typeof hiddenPrisonerDialog.showModal !== 'function') {
        return Promise.resolve('cancel');
      }

      return new Promise((resolve) => {
        const closeWith = (action) => {
          cleanup();
          hiddenPrisonerDialog.close();
          resolve(action);
        };

        const onClick = (event) => {
          const button = event.target.closest('button[data-action]');
          if (!button) {
            return;
          }

          if (button.dataset.action === 'show-and-generate') {
            closeWith('show-and-generate');
          }

          if (button.dataset.action === 'except-and-generate') {
            closeWith('except-and-generate');
          }

          if (button.dataset.action === 'cancel-generate') {
            closeWith('cancel');
          }
        };

        const onCancel = (event) => {
          event.preventDefault();
          closeWith('cancel');
        };

        const cleanup = () => {
          hiddenPrisonerDialog.removeEventListener('click', onClick);
          hiddenPrisonerDialog.removeEventListener('cancel', onCancel);
        };

        hiddenPrisonerDialog.addEventListener('click', onClick);
        hiddenPrisonerDialog.addEventListener('cancel', onCancel);
        hiddenPrisonerDialog.showModal();
      });
    }

    function isIdVisibleByFilters(id, filters) {
      if (!filters || !filters.buckets || !filters.seasons || !filters.ranks || !filters.times) {
        return true;
      }

      const bucket = Math.floor(id / 1000);
      if (bucket >= 1 && bucket <= 24 && !filters.buckets.has(String(bucket))) {
        return false;
      }

      const meta = state.idMetaById.get(id);
      if (!meta) {
        return true;
      }

      const season = typeof meta.season === 'string' ? meta.season : '';
      const seasonMatched = [
        '恒常',
        'SEASON 1',
        'SEASON 2',
        'SEASON 3',
        'SEASON 4',
        'SEASON 5',
        'SEASON 6',
        'SEASON 7',
        'WALPURGISNACHT',
        'COLLABORATION-LIMITED',
      ].some((token) => filters.seasons.has(token) && season.includes(token));
      if (!seasonMatched) {
        return false;
      }

      const rankKey = `${id < 13001 ? 'i' : 'e'}-${meta.rank}`;
      if (!filters.ranks.has(rankKey)) {
        return false;
      }

      const timeKey = (meta.time === 0 || meta.time === 1) ? '0,1' : String(meta.time);
      return filters.times.has(timeKey);
    }

    function shouldShowExceptRows() {
      return !toggleExceptRowsInput || toggleExceptRowsInput.checked;
    }

    function shouldSortByCalcValueDesc() {
      return state.changeParam === '1';
    }

    function shouldShowDiffOnly() {
      return state.changeParam === '2';
    }

    function orderVisibleIds(ids) {
      if (shouldSortByCalcValueDesc()) {
        return [...ids].sort((a, b) => {
          const valueA = state.baseValueById.get(a) ?? Number.NEGATIVE_INFINITY;
          const valueB = state.baseValueById.get(b) ?? Number.NEGATIVE_INFINITY;
          if (valueB !== valueA) {
            return valueB - valueA;
          }

          return a - b;
        });
      }

      return [...ids].sort((a, b) => a - b);
    }

    function buildDiffOnlyGroupedData(type) {
      const grouped = new Map();
      for (let group = 9; group >= 0; group -= 1) {
        grouped.set(group, []);
      }

      state.manualGroupById.forEach((groupValue, id) => {
        if (!belongsToType(id, type)) {
          return;
        }

        if (groupValue < 1 || groupValue > 9) {
          return;
        }

        grouped.get(groupValue).push(id);
      });

      getExceptSet(type).forEach((id) => {
        grouped.get(0).push(id);
      });

      return grouped;
    }

    function renderTypeRows(type, baseData, showExceptRows, filters) {
      let grouped;

      if (shouldShowDiffOnly()) {
        grouped = buildDiffOnlyGroupedData(type);
      } else {
        if (!baseData) {
          return '';
        }

        const workingData = cloneGroupedData(baseData);
        applyManualAndExceptOverrides(workingData.grouped, workingData.idToGroup, type);
        grouped = workingData.grouped;
      }

      return Array.from(grouped.entries())
        .filter(([groupValue]) => showExceptRows || groupValue !== 0)
        .map(([groupValue, ids]) => {
          const visibleIds = ids.filter((id) => isIdVisibleByFilters(id, filters));
          const orderedIds = orderVisibleIds(visibleIds);
          const label = getGroupLabel(groupValue);
          const tierClass = getGroupClass(groupValue);
          return `<tr><td class="tier-label ${tierClass}">${label}</td><td>${renderImageCells(orderedIds, groupValue, type)}</td></tr>`;
        }).join('');
    }

    function renderRows(tierlist, x) {
      const needsRebuild = (
        !state.baseGroupedByType.identity
        || !state.baseGroupedByType.ego
        || state.baseGroupedSnapshot.tierlist !== tierlist
        || state.baseGroupedSnapshot.x !== x
      );

      if (needsRebuild) {
        initializeBaseGroupedData(tierlist, x);
      }

      const showExceptRows = shouldShowExceptRows();
      const filters = {
        buckets: getActiveFilterKeys('bucket'),
        seasons: getActiveFilterKeys('season'),
        ranks: getActiveFilterKeys('rank'),
        times: getActiveFilterKeys('time'),
      };

      bodyIdentityEl.innerHTML = renderTypeRows('identity', state.baseGroupedByType.identity, showExceptRows, filters);
      bodyEgoEl.innerHTML = renderTypeRows('ego', state.baseGroupedByType.ego, showExceptRows, filters);
    }

    function clearGeneratedUrl() {
      if (generatedUrlInput) {
        generatedUrlInput.value = '';
        generatedUrlInput.rows = GENERATED_URL_BASE_ROWS;
        generatedUrlInput.classList.remove('dynamic-width');
        generatedUrlInput.style.removeProperty('--generated-url-width');
        generatedUrlInput.style.height = '';
      }
    }

    function getSelectedScrollFixMode() {
      const checked = document.querySelector('input[name="scrollFixMode"]:checked');
      return checked ? checked.value : 'group-relative';
    }

    function renderRowsWithScrollFix(targetId, sourceGroup, type, cursorY) {
      if (!state.tierlist || !Number.isFinite(state.x)) {
        return;
      }

      const beforeImg = document.querySelector(`img[alt="${targetId}"]`);
      if (!beforeImg) {
        renderRows(state.tierlist, state.x);
        return;
      }

      const mode = getSelectedScrollFixMode();
      state.scrollFixMode = mode;

      if (mode === 'group-relative') {
        const beforeRow = beforeImg.closest('tr');
        if (beforeRow && Number.isFinite(cursorY) && Number.isInteger(sourceGroup)) {
          const beforeCursorOffset = cursorY - beforeRow.getBoundingClientRect().top;

          renderRows(state.tierlist, state.x);

          const tbody = type === 'identity' ? bodyIdentityEl : bodyEgoEl;
          const sourceLabel = getGroupLabel(sourceGroup);
          const afterSourceRow = tbody
            ? Array.from(tbody.querySelectorAll('tr')).find((row) => row.querySelector('td')?.textContent === sourceLabel)
            : null;

          if (afterSourceRow) {
            const afterRowTop = afterSourceRow.getBoundingClientRect().top;
            const desiredTop = cursorY - beforeCursorOffset;
            window.scrollBy(0, afterRowTop - desiredTop);
            return;
          }
        }
      }

      const beforeTop = beforeImg.getBoundingClientRect().top;
      renderRows(state.tierlist, state.x);
      setTimeout(() => {
        const afterImg = document.querySelector(`img[alt="${targetId}"]`);
        if (!afterImg) {
          return;
        }

        const afterTop = afterImg.getBoundingClientRect().top;
        window.scrollBy(0, afterTop - beforeTop);
      }, 0);
    }

    function handleMove(id, type, currentGroup, delta, cursorY) {
      if (!Number.isInteger(id) || !Number.isInteger(currentGroup) || !Number.isInteger(delta)) {
        return;
      }

      const target = currentGroup + delta;
      if (target < 1 || target > 9) {
        return;
      }

      getExceptSet(type).delete(id);
      state.exceptRestoreGroupById.delete(id);
      setManualGroupOverride(id, type, target);
      clearGeneratedUrl();

      renderRowsWithScrollFix(id, currentGroup, type, cursorY);
    }

    function handleExceptToggle(id, type, currentGroup, include, cursorY) {
      if (!Number.isInteger(id) || !Number.isInteger(currentGroup)) {
        return;
      }

      const exceptIds = getExceptSet(type);

      if (include) {
        exceptIds.delete(id);

        const restoreGroup = state.exceptRestoreGroupById.get(id);
        if (Number.isInteger(restoreGroup) && restoreGroup >= 1 && restoreGroup <= 9) {
          setManualGroupOverride(id, type, restoreGroup);
        }
      } else {
        if (currentGroup > 0) {
          state.exceptRestoreGroupById.set(id, currentGroup);
        }

        exceptIds.add(id);
      }

      clearGeneratedUrl();

      if (state.tierlist && Number.isFinite(state.x)) {
        renderRowsWithScrollFix(id, currentGroup, type, cursorY);
      }
    }

    function parseControlPayload(el) {
      const id = Number.parseInt(el.dataset.id ?? '', 10);
      const type = el.dataset.type;
      const group = Number.parseInt(el.dataset.group ?? '', 10);

      if (!Number.isInteger(id) || !Number.isInteger(group) || (type !== 'identity' && type !== 'ego')) {
        return null;
      }

      return { id, type, group };
    }

    function onControlClick(event) {
      const controlButton = event.target.closest('button[data-action]');
      if (!controlButton) {
        return;
      }

      const payload = parseControlPayload(controlButton);
      if (!payload) {
        return;
      }

      if (controlButton.dataset.action === 'move') {
        const delta = Number.parseInt(controlButton.dataset.delta ?? '', 10);
        handleMove(payload.id, payload.type, payload.group, delta, event.clientY);
        return;
      }

      if (controlButton.dataset.action === 'toggle-except') {
        const include = controlButton.dataset.include === '1';
        handleExceptToggle(payload.id, payload.type, payload.group, include, event.clientY);
      }
    }

    bodyIdentityEl.addEventListener('click', onControlClick);
    bodyEgoEl.addEventListener('click', onControlClick);

    function applyAdjustControlVisibility(show) {
      document.body.classList.toggle('hide-adjust-controls', !show);
    }

    function applyExceptMoveControlVisibility(show) {
      document.body.classList.toggle('hide-except-move-controls', !show);
    }

    if (toggleAdjustControlsInput) {
      toggleAdjustControlsInput.addEventListener('change', () => {
        applyAdjustControlVisibility(toggleAdjustControlsInput.checked);
      });

      applyAdjustControlVisibility(toggleAdjustControlsInput.checked);
    }

    if (toggleExceptMoveControlsInput) {
      toggleExceptMoveControlsInput.addEventListener('change', () => {
        applyExceptMoveControlVisibility(toggleExceptMoveControlsInput.checked);
      });

      applyExceptMoveControlVisibility(toggleExceptMoveControlsInput.checked);
    }

    if (toggleExceptRowsInput) {
      toggleExceptRowsInput.addEventListener('change', () => {
        if (state.tierlist && Number.isFinite(state.x)) {
          renderRows(state.tierlist, state.x);
        }
      });
    }

    [toggleName1Input, toggleName2Input].forEach((input) => {
      if (!input) {
        return;
      }

      input.addEventListener('change', () => {
        if (state.tierlist && Number.isFinite(state.x)) {
          renderRows(state.tierlist, state.x);
        }
      });
    });

    renderIdRangeFilters();

    if (idRangeFiltersEl) {
      idRangeFiltersEl.addEventListener('change', (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement) || target.dataset.action !== 'toggle-id-range') {
          return;
        }

        if (state.tierlist && Number.isFinite(state.x)) {
          renderRows(state.tierlist, state.x);
        }
      });

      idRangeFiltersEl.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-action]');
        if (!button) {
          return;
        }

        const action = button.dataset.action;
        if (action !== 'clear-group-ranges' && action !== 'check-group-ranges') {
          return;
        }

        const container = button.closest('.id-range-subgroup') || button.closest('.id-range-group');
        setRangeFiltersInContainer(container, action === 'check-group-ranges');
      });
    }

    function encodeDiffId(id) {
      const high = Math.floor(id / 1000);
      const low = id % 100;

      if (high > 35 || low > 35) {
        throw new Error(`ID ${id} は圧縮形式の範囲外です（上位・下位とも35以下が必要）`);
      }

      return {
        id,
        high,
        low,
        highChar: high.toString(36),
        lowChar: low.toString(36),
        lowPadded: String(low).padStart(2, '0'),
      };
    }

    function compressEncodedIds(ids, codingDiffId = 0) {
      const encoded = ids
        .slice()
        .sort((a, b) => a - b)
        .map((id) => encodeDiffId(id));

      let result = '';
      let index = 0;

      while (index < encoded.length) {
        const start = encoded[index];
        let endIndex = index;

        while (
          endIndex + 1 < encoded.length
          && encoded[endIndex + 1].high === start.high
          && encoded[endIndex + 1].low === encoded[endIndex].low + 1
        ) {
          endIndex += 1;
        }

        const runLength = endIndex - index + 1;
        if (runLength >= 3) {
          if (codingDiffId === 1) {
            result += `${start.highChar}${start.lowPadded}~${encoded[endIndex].lowPadded}`;
          } else {
            result += `${start.highChar}${start.lowChar}~${encoded[endIndex].lowChar}`;
          }
          index = endIndex + 1;
          continue;
        }

        for (let i = index; i <= endIndex; i += 1) {
          if (codingDiffId === 1) {
            result += `${encoded[i].highChar}${encoded[i].lowPadded}`;
          } else {
            result += `${encoded[i].highChar}${encoded[i].lowChar}`;
          }
        }

        index = endIndex + 1;
      }

      return result;
    }

    function toBase64Url(input) {
      return btoa(input)
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/g, '');
    }

    function fromBase64Url(input) {
      const normalized = input
        .replace(/-/g, '+')
        .replace(/_/g, '/');

      const padLength = (4 - (normalized.length % 4)) % 4;
      return atob(`${normalized}${'='.repeat(padLength)}`);
    }

    function decodeSection(section, codingDiffId = 0) {
      if (!section) {
        return [];
      }

      const ids = [];
      let i = 0;

      while (i < section.length) {
        const highChar = section[i];
        const lowCharLength = codingDiffId === 1 ? 2 : 1;
        const lowStartRaw = section.slice(i + 1, i + 1 + lowCharLength);

        if (!highChar || lowStartRaw.length !== lowCharLength) {
          throw new Error('Cパラメータの形式が不正です（ID桁不足）');
        }

        const high = Number.parseInt(highChar, 36);
        const lowStart = Number.parseInt(lowStartRaw, codingDiffId === 1 ? 10 : 36);

        if (!Number.isInteger(high) || !Number.isInteger(lowStart)) {
          throw new Error('Cパラメータの形式が不正です（base36変換失敗）');
        }

        const rangeMark = section[i + 1 + lowCharLength];
        if (rangeMark === '~') {
          const lowEndRaw = section.slice(i + 2 + lowCharLength, i + 2 + (lowCharLength * 2));
          const lowEnd = Number.parseInt(lowEndRaw ?? '', codingDiffId === 1 ? 10 : 36);

          if (!Number.isInteger(lowEnd) || lowEnd < lowStart) {
            throw new Error('Cパラメータの形式が不正です（範囲指定）');
          }

          for (let low = lowStart; low <= lowEnd; low += 1) {
            ids.push(high * 1000 + low);
          }

          i += 2 + (lowCharLength * 2);
          continue;
        }

        ids.push(high * 1000 + lowStart);
        i += 1 + lowCharLength;
      }

      return ids;
    }

    function parseCompressedDiffParam(cParam) {
      if (!cParam) {
        return { codingDiffId: 0, payload: cParam };
      }

      if (cParam.startsWith('1:')) {
        return {
          codingDiffId: 1,
          payload: cParam.slice(2),
        };
      }

      return {
        codingDiffId: 0,
        payload: cParam,
      };
    }

    function applyCompressedDiffParam(cParam) {
      resetDiffState();

      const { codingDiffId, payload } = parseCompressedDiffParam(cParam);

      if (!payload) {
        return;
      }

      const decoded = fromBase64Url(payload);
      const sections = decoded.split('.');
      if (sections.length !== 10) {
        throw new Error('Cパラメータの形式が不正です（セクション数）');
      }

      for (let sectionIndex = 0; sectionIndex < sections.length; sectionIndex += 1) {
        const group = 9 - sectionIndex;
        const ids = decodeSection(sections[sectionIndex], codingDiffId);

        ids.forEach((id) => {
          if (group === 0) {
            if (belongsToType(id, 'identity')) {
              state.exceptIdentityIds.add(id);
            } else {
              state.exceptEgoIds.add(id);
            }
            return;
          }

          setManualGroupOverride(id, belongsToType(id, 'identity') ? 'identity' : 'ego', group);
        });
      }
    }

    function buildCompressedDiffParam(codingDiffId = 0) {
      const idsByGroup = new Map();
      for (let group = 0; group <= 9; group += 1) {
        idsByGroup.set(group, []);
      }

      const exceptAll = new Set([...state.exceptIdentityIds, ...state.exceptEgoIds]);

      state.manualGroupById.forEach((group, id) => {
        if (exceptAll.has(id)) {
          return;
        }

        if (group >= 1 && group <= 9) {
          idsByGroup.get(group).push(id);
        }
      });

      exceptAll.forEach((id) => idsByGroup.get(0).push(id));

      const sections = [];
      for (let group = 9; group >= 0; group -= 1) {
        sections.push(compressEncodedIds(idsByGroup.get(group), codingDiffId));
      }

      const encodedPayload = toBase64Url(sections.join('.'));
      if (codingDiffId === 1) {
        return `1:${encodedPayload}`;
      }

      return encodedPayload;
    }

    function generateShareUrlCore() {
      if (!state.tierlist || !Number.isFinite(state.x)) {
        return;
      }

      try {
        const compressed = buildCompressedDiffParam(changecodingDIffID);
        const url = `https://394ast.github.io/limbus.tiermaker/?T=${state.tableIndex}&X=${state.x}&C=${compressed}`;

        if (generatedUrlInput) {
          generatedUrlInput.value = url;
          const estimatedWidthPx = Math.max(
            GENERATED_URL_BASE_WIDTH_PX,
            Math.min(2200, Math.ceil(url.length * 8.2))
          );
          const estimatedRows = Math.max(
            GENERATED_URL_BASE_ROWS,
            Math.min(10, Math.ceil(url.length / 140))
          );
          generatedUrlInput.rows = estimatedRows;
          generatedUrlInput.style.setProperty('--generated-url-width', `${estimatedWidthPx}px`);
          generatedUrlInput.classList.add('dynamic-width');
          generatedUrlInput.style.height = 'auto';
          generatedUrlInput.style.height = `${generatedUrlInput.scrollHeight}px`;
          generatedUrlInput.focus();
          generatedUrlInput.select();
        }
      } catch (err) {
        if (generatedUrlInput) {
          generatedUrlInput.value = `URL生成エラー: ${err.message}`;
        }
      }
    }

    async function generateShareUrl() {
      if (!state.tierlist || !Number.isFinite(state.x)) {
        return;
      }

      if (!hasUncheckedRangeFilters()) {
        generateShareUrlCore();
        return;
      }

      const hiddenIds = getHiddenPrisonerIds();
      if (hiddenIds.length === 0) {
        generateShareUrlCore();
        return;
      }

      const selectedAction = await promptHiddenPrisonerChoice();
      if (selectedAction === 'show-and-generate') {
        setAllRangeFilters(true);
        generateShareUrlCore();
        return;
      }

      if (selectedAction === 'except-and-generate') {
        moveIdsToExcept(hiddenIds);
        clearGeneratedUrl();

        if (state.tierlist && Number.isFinite(state.x)) {
          renderRows(state.tierlist, state.x);
        }

        generateShareUrlCore();
      }
    }

    function applyCustomSize(width) {
      document.documentElement.style.setProperty('--img-size', `${width}px`);
    }

    imgSizeForm.addEventListener('change', (event) => {
      if (event.target.type !== 'radio') {
        return;
      }

      const selectedSize = event.target.value;
      if (selectedSize === 'custom') {
        const currentSize = Number.parseInt(
          getComputedStyle(document.documentElement).getPropertyValue('--img-size') ?? '',
          10
        );
        customWidthInput.value = Number.isInteger(currentSize) && currentSize > 0 ? currentSize : 80;
        customWidthInput.disabled = false;
        customWidthInput.focus();
        applyCustomSize(Number.parseInt(customWidthInput.value, 10));
        return;
      }

      customWidthInput.value = '';
      customWidthInput.disabled = true;

      if (selectedSize === 'size1') applyCustomSize(60);
      if (selectedSize === 'size2') applyCustomSize(80);
      if (selectedSize === 'size3') applyCustomSize(120);
      if (selectedSize === 'size4') applyCustomSize(200);
    });

    customWidthInput.addEventListener('input', () => {
      const selected = document.querySelector('input[name="imgSize"]:checked');
      if (!selected || selected.value !== 'custom') {
        return;
      }

      let customWidth = Number.parseInt(customWidthInput.value ?? '', 10);
      if (!Number.isInteger(customWidth)) {
        return;
      }

      customWidth = Math.max(20, Math.min(customWidth, 1000));
      setTimeout(() => applyCustomSize(customWidth), 100);
    });

    applyCustomSize(120);

    const DEFAULT_T = 0;
    const DEFAULT_X = 1;

    function getQuerySettings() {
      const params = new URLSearchParams(window.location.search);
      const tableParam = params.get('T');
      const xParam = params.get('X');
      const changeParam = params.get('S');
      const compressedParam = changeParam === '1' ? null : params.get('C');

      state.changeParam = changeParam;

      if (toggleAdjustControlsInput && changeParam === '1') {
        toggleAdjustControlsInput.checked = false;
        applyAdjustControlVisibility(false);
      }

      if (statusEl) {
        statusEl.hidden = !(changeParam !== null && changeParam !== '');
      }

      const tableIndex = Number.parseInt(tableParam ?? String(DEFAULT_T), 10);
      const xValue = xParam !== null ? Number(xParam) : DEFAULT_X;

      return {
        tableIndex: Number.isInteger(tableIndex) && tableIndex >= 0 ? tableIndex : DEFAULT_T,
        xValue,
        compressedParam,
      };
    }

    async function loadAndRender() {
      const { tableIndex, xValue, compressedParam } = getQuerySettings();
      const x = xValue;

      if (!Number.isFinite(x)) {
        statusEl.textContent = 'URLクエリ X は数値で指定してください。例: ?T=0&X=1';
        statusEl.className = 'error';
        return;
      }

      try {
        const [tableResponse, namelistResponse] = await Promise.all([
          fetch(`data/table${tableIndex}.json`, { cache: 'no-store' }),
          fetch('namelist.json', { cache: 'no-store' }),
        ]);

        if (!tableResponse.ok) {
          throw new Error(`data/table${tableIndex}.json の取得に失敗しました (HTTP ${tableResponse.status})`);
        }

        if (!namelistResponse.ok) {
          throw new Error(`namelist.json の取得に失敗しました (HTTP ${namelistResponse.status})`);
        }

        const [tierlist, namelist] = await Promise.all([
          tableResponse.json(),
          namelistResponse.json(),
        ]);

        const nameDataById = new Map();
        const idMetaById = new Map();
        namelist.forEach((entry) => {
          const id = Number.parseInt(entry?.id ?? '', 10);
          if (!Number.isInteger(id)) {
            return;
          }

          const rank = Number.parseInt(entry?.rank ?? '', 10);
          const time = Number.parseInt(entry?.time ?? '', 10);
          idMetaById.set(id, {
            season: typeof entry?.season === 'string' ? entry.season : '',
            rank: Number.isInteger(rank) ? rank : null,
            time: Number.isInteger(time) ? time : null,
          });

          if (typeof entry?.name1 === 'string' || typeof entry?.name2 === 'string') {
            nameDataById.set(id, {
              name1: entry.name1 ?? '',
              name2: entry.name2 ?? '',
            });
            return;
          }

          const baseName = typeof entry?.name === 'string' ? entry.name.trim() : '';
          const nameTokens = baseName ? baseName.split(/\s+/) : [];
          nameDataById.set(id, {
            name1: nameTokens[0] ?? '',
            name2: nameTokens.slice(1).join(' '),
          });
        });

        state.tierlist = tierlist;
        state.x = x;
        state.tableIndex = tableIndex;
        state.nameDataById = nameDataById;
        state.idMetaById = idMetaById;
        initializeBaseGroupedData(tierlist, x);
        applyCompressedDiffParam(compressedParam);
        renderRows(tierlist, x);

        statusEl.textContent = `読み込み完了（table${tableIndex} / 件数: ${tierlist.length} / X: ${x}）`;
        statusEl.className = '';

      } catch (err) {
        statusEl.textContent = `エラー: ${err.message}`;
        statusEl.className = 'error';
        bodyIdentityEl.innerHTML = '';
        bodyEgoEl.innerHTML = '';
        state.baseGroupedByType.identity = null;
        state.baseGroupedByType.ego = null;
        state.baseGroupedSnapshot.tierlist = null;
        state.baseGroupedSnapshot.x = null;
      }
    }

    syncModeInputs.forEach((input) => {
      input.addEventListener('change', () => {
        if (state.tierlist && Number.isFinite(state.x)) {
          renderRows(state.tierlist, state.x);
        }
      });
    });

    scrollFixModeInputs.forEach((input) => {
      input.addEventListener('change', () => {
        state.scrollFixMode = input.value;
      });
    });

    if (generateUrlButton) {
      generateUrlButton.addEventListener('click', generateShareUrl);
    }

    if (openLatestTierButton) {
      openLatestTierButton.addEventListener('click', openLatestTierWithCushion);
    }


    function openLatestTierWithCushion() {
      const ok = window.confirm('https://394ast.github.io/limbus.tiermaker/ に移動します。\nよろしいですか？');
      if (!ok) {
        return;
      }

      window.location.href = 'https://394ast.github.io/limbus.tiermaker/';
    }

    loadAndRender();
  </script>
</body>
</html>
