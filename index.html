<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>みんなでつくる　リンバスTier表</title>
    <style>
      body { font-family: sans-serif; margin: 24px; }
      .grid-line { margin: 8px 0 12px; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
      .indent { font-weight: 600; }
      #imgSizeForm input[type="number"] { width: 72px; }
      .sync-mode { margin: 8px 0 12px; }
      .sync-mode label { margin-right: 12px; }
      .id-range-filters { margin: 8px 0 12px; border: 1px solid #ccc; border-radius: 6px; padding: 8px; }
      .id-range-group { margin-bottom: 8px; }
      .id-range-title { font-weight: 600; margin: 0 0 4px; }
      .id-range-options { display: flex; flex-wrap: wrap; gap: 4px 12px; }
      .id-range-filter { font-size: 12px; white-space: nowrap; }
      .id-range-actions { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 4px; }
      table { border-collapse: collapse; width: 100%; max-width: none; margin-bottom: 20px; }
      th, td { border: 1px solid #ccc; padding: 6px 8px; text-align: right; }
      th:first-child, td:first-child { text-align: center; max-width: 20px; width: 20px; }
      th:nth-child(2), td:nth-child(2) { text-align: left; }
      .tier-label { font-weight: 700; }
      .tier-ss { background-color: #f0c7c7; }
      .tier-s-plus { background-color: #f1d0c5; }
      .tier-s { background-color: #f1dcc9; }
      .tier-s-minus { background-color: #eee8cd; }
      .tier-a { background-color: #e2edcf; }
      .tier-b { background-color: #d5eade; }
      .tier-c { background-color: #d0e6ee; }
      .tier-d { background-color: #ccddf0; }
      .tier-e { background-color: #c8d4ee; }
      .tier-except { background-color: #ececec; color: #555; }
      .error { color: #b00020; }
      .id-items { display: flex; flex-wrap: wrap; gap: 4px; justify-content: flex-start; }
      .id-item { display: flex; align-items: center; gap: 6px; border: 1px solid #ddd; border-radius: 4px; padding: 4px; background: #fff; }
      .id-item img { width: var(--img-size, 56px); height: var(--img-size, 56px); object-fit: cover; border-radius: 4px; border: 1px solid #ddd; }
      .id-controls { display: flex; flex-direction: column; align-items: stretch; gap: 4px; }
      .id-controls button:disabled { opacity: 0.4; cursor: not-allowed; }
      .id-controls label { font-size: 12px; }
      .hide-adjust-controls .id-controls { display: none; }
      .share-url-tools { margin: 8px 0 12px; display: grid; gap: 6px; }
      #generatedUrl { width: 100%; max-width: 900px; }
    </style>
</head>
<body>
  <h2>みんなでつくる　リンバスTier表</h2>

  <div id="status" aria-live="polite" hidden></div>

  <div id="idRangeFilters" class="id-range-filters"></div>

  <div class="grid-line">
    <span class="indent">画像サイズ:</span><div id="imgSizeForm">
      <input type="radio" name="imgSize" value="size1">小
      <input type="radio" name="imgSize" value="size2">中
      <input type="radio" name="imgSize" value="size3" checked>大
      <input type="radio" name="imgSize" value="size4">特大<br>
      <input type="radio" name="imgSize" value="custom">カスタム <input type="number" id="customWidth" disabled>px
    </div>
  </div>

  <div class="sync-mode">
    <span class="indent">人格画像:</span>
    <label><input type="radio" name="syncMode" value="before"> 同期前</label>
    <label><input type="radio" name="syncMode" value="after" checked> 同期後</label>
  </div>

  <div class="sync-mode">
    <label><input type="checkbox" id="toggleAdjustControls" checked> Tierの移動ボタンを表示</label>
  </div>

  <div class="sync-mode">
    <label><input type="checkbox" id="toggleExceptRows" checked> 除外ランクを表示する</label>
  </div>

  <div class="share-url-tools">
    <button type="button" id="generateUrlButton">URLを生成する</button>
    <input type="text" id="generatedUrl" readonly placeholder="生成されたURLがここに表示されます">
  </div>

  <h3>人格Tier</h3>
  <table>
    <tbody id="resultBodyIdentity"></tbody>
  </table>

  <h3>E.G.O.Tier</h3>
  <table>
    <tbody id="resultBodyEgo"></tbody>
  </table>

  <script>
    const statusEl = document.getElementById('status');
    const bodyIdentityEl = document.getElementById('resultBodyIdentity');
    const bodyEgoEl = document.getElementById('resultBodyEgo');
    const syncModeInputs = document.querySelectorAll('input[name="syncMode"]');
    const imgSizeForm = document.getElementById('imgSizeForm');
    const customWidthInput = document.getElementById('customWidth');
    const toggleAdjustControlsInput = document.getElementById('toggleAdjustControls');
    const toggleExceptRowsInput = document.getElementById('toggleExceptRows');
    const idRangeFiltersEl = document.getElementById('idRangeFilters');
    const generateUrlButton = document.getElementById('generateUrlButton');
    const generatedUrlInput = document.getElementById('generatedUrl');

    const state = {
      tierlist: null,
      x: null,
      tableIndex: 0,
      manualGroupById: new Map(),
      exceptIdentityIds: new Set(),
      exceptEgoIds: new Set(),
      exceptRestoreGroupById: new Map(),
      baseGroupedByType: {
        identity: null,
        ego: null,
      },
      baseGroupedSnapshot: {
        tierlist: null,
        x: null,
      },
      changeParam: null,
    };

    const GROUP_META = {
      9: { label: 'SS', className: 'tier-ss' },
      8: { label: 'S+', className: 'tier-s-plus' },
      7: { label: 'S', className: 'tier-s' },
      6: { label: 'S-', className: 'tier-s-minus' },
      5: { label: 'A', className: 'tier-a' },
      4: { label: 'B', className: 'tier-b' },
      3: { label: 'C', className: 'tier-c' },
      2: { label: 'D', className: 'tier-d' },
      1: { label: 'E', className: 'tier-e' },
      0: { label: '除外', className: 'tier-except' },
    };

    function calcValue(row, x) {
      const numerator = row[1] + 0.01 * x * row[3];
      const denominator = row[2] + 0.01 * x * row[4];
      return denominator === 0 ? NaN : numerator / denominator;
    }

    function belongsToType(id, type) {
      return type === 'identity' ? id < 13001 : id >= 13001;
    }

    function getExceptSet(type) {
      return type === 'identity' ? state.exceptIdentityIds : state.exceptEgoIds;
    }

    function buildGroupedData(rows, x) {
      const grouped = new Map();
      const idToGroup = new Map();

      for (let group = 9; group >= 0; group -= 1) {
        grouped.set(group, []);
      }

      rows.forEach((row) => {
        const id = row[0];
        const value = calcValue(row, x);

        if (!Number.isFinite(value)) {
          throw new Error(`ID ${id} の計算結果が不正です。`);
        }

        if (value < 1 || value > 9) {
          throw new Error(`ID ${id} の計算結果が範囲外です: ${value}（1以上9以下である必要があります）`);
        }

        const rounded = Math.round(value);

        if (!grouped.has(rounded)) {
          throw new Error(`ID ${id} の丸め後グループが範囲外です: ${rounded}`);
        }

        grouped.get(rounded).push(id);
        idToGroup.set(id, rounded);
      });

      return { grouped, idToGroup };
    }


    function cloneGroupedData(baseData) {
      const grouped = new Map();
      baseData.grouped.forEach((ids, groupValue) => {
        grouped.set(groupValue, [...ids]);
      });

      return {
        grouped,
        idToGroup: new Map(baseData.idToGroup),
      };
    }

    function initializeBaseGroupedData(tierlist, x) {
      const identityRows = [];
      const egoRows = [];

      tierlist.forEach((row) => {
        if (row[0] < 13001) {
          identityRows.push(row);
          return;
        }

        egoRows.push(row);
      });

      state.baseGroupedByType.identity = buildGroupedData(identityRows, x);
      state.baseGroupedByType.ego = buildGroupedData(egoRows, x);
      state.baseGroupedSnapshot.tierlist = tierlist;
      state.baseGroupedSnapshot.x = x;
    }

    function getBaseGroupForId(type, id) {
      const baseData = state.baseGroupedByType[type];
      if (!baseData) {
        return null;
      }

      const baseGroup = baseData.idToGroup.get(id);
      return Number.isInteger(baseGroup) ? baseGroup : null;
    }

    function setManualGroupOverride(id, type, targetGroup) {
      const baseGroup = getBaseGroupForId(type, id);
      if (baseGroup !== null && targetGroup === baseGroup) {
        state.manualGroupById.delete(id);
        return;
      }

      state.manualGroupById.set(id, targetGroup);
    }

    function resetDiffState() {
      state.manualGroupById.clear();
      state.exceptIdentityIds.clear();
      state.exceptEgoIds.clear();
      state.exceptRestoreGroupById.clear();
    }

    function moveIdBetweenGroups(grouped, idToGroup, id, targetGroup) {
      const fromGroup = idToGroup.get(id);

      if (!Number.isInteger(fromGroup) || !grouped.has(fromGroup) || !grouped.has(targetGroup)) {
        return;
      }

      if (fromGroup === targetGroup) {
        return;
      }

      grouped.set(fromGroup, grouped.get(fromGroup).filter((currentId) => currentId !== id));
      grouped.get(targetGroup).push(id);
      idToGroup.set(id, targetGroup);
    }

    function applyManualAndExceptOverrides(grouped, idToGroup, type) {
      state.manualGroupById.forEach((targetGroup, id) => {
        if (!belongsToType(id, type)) {
          return;
        }

        if (!idToGroup.has(id) || targetGroup < 1 || targetGroup > 9) {
          return;
        }

        moveIdBetweenGroups(grouped, idToGroup, id, targetGroup);
      });

      const exceptIds = getExceptSet(type);
      exceptIds.forEach((id) => {
        if (!idToGroup.has(id)) {
          return;
        }

        moveIdBetweenGroups(grouped, idToGroup, id, 0);
      });
    }

    function getIdentityImageUrl(id) {
      const checked = document.querySelector('input[name="syncMode"]:checked');
      const syncMode = checked ? checked.value : 'before';

      if (syncMode === 'after') {
        return `https://raw.githubusercontent.com/394ast/limbus.sharetool/main/Identities.After/${id}.3.jpg`;
      }

      return `https://raw.githubusercontent.com/394ast/limbus.sharetool/main/Identities.Before/${id}.1.jpg`;
    }

    function getEgoImageUrl(id) {
      return `https://raw.githubusercontent.com/394ast/limbus.sharetool/main/EGO/${id}.jpg`;
    }

    function renderControlButtons(id, groupValue, isExcept, type) {
      const includeChecked = getExceptSet(type).has(id) ? '' : 'checked';

      if (isExcept) {
        return `<label><input type="checkbox" data-action="toggle-except" data-id="${id}" data-type="${type}" data-group="${groupValue}" ${includeChecked}> </label>`;
      }

      const disablePlus2 = groupValue >= 8;
      const disablePlus1 = groupValue >= 9;
      const disableMinus1 = groupValue <= 1;
      const disableMinus2 = groupValue <= 2;

      return [
        `<button type="button" data-action="move" data-delta="2" data-id="${id}" data-type="${type}" data-group="${groupValue}" ${disablePlus2 ? 'disabled' : ''}>+2</button>`,
        `<button type="button" data-action="move" data-delta="1" data-id="${id}" data-type="${type}" data-group="${groupValue}" ${disablePlus1 ? 'disabled' : ''}>+1</button>`,
        `<label><input type="checkbox" data-action="toggle-except" data-id="${id}" data-type="${type}" data-group="${groupValue}" ${includeChecked}> </label>`,
        `<button type="button" data-action="move" data-delta="-1" data-id="${id}" data-type="${type}" data-group="${groupValue}" ${disableMinus1 ? 'disabled' : ''}>-1</button>`,
        `<button type="button" data-action="move" data-delta="-2" data-id="${id}" data-type="${type}" data-group="${groupValue}" ${disableMinus2 ? 'disabled' : ''}> -2</button>`
      ].join('');
    }

    function renderImageCells(ids, groupValue, type) {
      const isExcept = groupValue === 0;

      const items = ids.map((id) => {
        const src = type === 'identity' ? getIdentityImageUrl(id) : getEgoImageUrl(id);

        return `
          <div class="id-item">
            <img src="${src}" alt="${id}" loading="lazy">
            <div class="id-controls">
              ${renderControlButtons(id, groupValue, isExcept, type)}
            </div>
          </div>
        `;
      }).join('');

      return `<div class="id-items">${items}</div>`;
    }

    function getGroupLabel(groupValue) {
      return GROUP_META[groupValue]?.label ?? String(groupValue);
    }

    function getGroupClass(groupValue) {
      return GROUP_META[groupValue]?.className ?? '';
    }

    function getIdRangeFilters() {
      const displayNames = [
        'イサン', 'ファウスト', 'ドンキホーテ', '良秀', 'ムルソー', 'ホンル',
        'ヒースクリフ', 'イシュメール', 'ロージャ', 'シンクレア', 'ウーティス', 'グレゴール'
      ];

      const identity = displayNames.map((name, i) => ({ bucket: i + 1, name }));
      const ego = displayNames.map((name, i) => ({ bucket: i + 13, name }));

      return { identity, ego };
    }

    function renderIdRangeFilters() {
      if (!idRangeFiltersEl) {
        return;
      }

      const { identity, ego } = getIdRangeFilters();

      const renderOptions = (items) => items.map(({ bucket, name }) => {
        return `<label class="id-range-filter"><input type="checkbox" data-action="toggle-id-range" data-bucket="${bucket}" checked> ${name}</label>`;
      }).join('');

      idRangeFiltersEl.innerHTML = [
        `<div class="id-range-group"><p class="id-range-title">表示する人格</p><div class="id-range-options">${renderOptions(identity)}</div></div>`,
        `<div class="id-range-group"><p class="id-range-title">表示するE.G.O.</p><div class="id-range-options">${renderOptions(ego)}</div></div>`,
        '<div class="id-range-actions"><button type="button" data-action="clear-all-ranges">全解除</button><button type="button" data-action="check-all-ranges">全表示</button></div>'
      ].join('');
    }

    function setAllRangeFilters(checked) {
      if (!idRangeFiltersEl) {
        return;
      }

      const checkboxes = idRangeFiltersEl.querySelectorAll('input[data-action="toggle-id-range"]');
      checkboxes.forEach((checkbox) => {
        checkbox.checked = checked;
      });

      if (state.tierlist && Number.isFinite(state.x)) {
        renderRows(state.tierlist, state.x);
      }
    }

    function getVisibleBuckets() {
      if (!idRangeFiltersEl) {
        return null;
      }

      const visibleBuckets = new Set();
      const checkboxes = idRangeFiltersEl.querySelectorAll('input[data-action="toggle-id-range"]:checked');
      checkboxes.forEach((checkbox) => {
        const bucket = Number.parseInt(checkbox.dataset.bucket ?? '', 10);
        if (Number.isInteger(bucket)) {
          visibleBuckets.add(bucket);
        }
      });

      return visibleBuckets;
    }

    function isIdVisibleByRange(id, visibleBuckets) {
      if (!visibleBuckets) {
        return true;
      }

      const bucket = Math.floor(id / 1000);
      if (bucket < 1 || bucket > 24) {
        return true;
      }

      return visibleBuckets.has(bucket);
    }

    function shouldShowExceptRows() {
      return !toggleExceptRowsInput || toggleExceptRowsInput.checked;
    }

    function shouldSortIdsAscending() {
      return state.changeParam !== '1';
    }

    function renderTypeRows(type, baseData, showExceptRows, visibleBuckets) {
      if (!baseData) {
        return '';
      }

      const workingData = cloneGroupedData(baseData);
      applyManualAndExceptOverrides(workingData.grouped, workingData.idToGroup, type);

      return Array.from(workingData.grouped.entries())
        .filter(([groupValue]) => showExceptRows || groupValue !== 0)
        .map(([groupValue, ids]) => {
          const visibleIds = ids.filter((id) => isIdVisibleByRange(id, visibleBuckets));
          const orderedIds = shouldSortIdsAscending() ? [...visibleIds].sort((a, b) => a - b) : visibleIds;
          const label = getGroupLabel(groupValue);
          const tierClass = getGroupClass(groupValue);
          return `<tr><td class="tier-label ${tierClass}">${label}</td><td>${renderImageCells(orderedIds, groupValue, type)}</td></tr>`;
        }).join('');
    }

    function renderRows(tierlist, x) {
      const needsRebuild = (
        !state.baseGroupedByType.identity
        || !state.baseGroupedByType.ego
        || state.baseGroupedSnapshot.tierlist !== tierlist
        || state.baseGroupedSnapshot.x !== x
      );

      if (needsRebuild) {
        initializeBaseGroupedData(tierlist, x);
      }

      const showExceptRows = shouldShowExceptRows();
      const visibleBuckets = getVisibleBuckets();

      bodyIdentityEl.innerHTML = renderTypeRows('identity', state.baseGroupedByType.identity, showExceptRows, visibleBuckets);
      bodyEgoEl.innerHTML = renderTypeRows('ego', state.baseGroupedByType.ego, showExceptRows, visibleBuckets);
    }

    function handleMove(id, type, currentGroup, delta) {
      if (!Number.isInteger(id) || !Number.isInteger(currentGroup) || !Number.isInteger(delta)) {
        return;
      }

      const target = currentGroup + delta;
      if (target < 1 || target > 9) {
        return;
      }

      getExceptSet(type).delete(id);
      state.exceptRestoreGroupById.delete(id);
      setManualGroupOverride(id, type, target);

      if (state.tierlist && Number.isFinite(state.x)) {
        renderRows(state.tierlist, state.x);
      }
    }

    function handleExceptToggle(id, type, currentGroup, checked) {
      if (!Number.isInteger(id) || !Number.isInteger(currentGroup)) {
        return;
      }

      const exceptIds = getExceptSet(type);

      if (checked) {
        exceptIds.delete(id);

        const restoreGroup = state.exceptRestoreGroupById.get(id);
        if (Number.isInteger(restoreGroup) && restoreGroup >= 1 && restoreGroup <= 9) {
          setManualGroupOverride(id, type, restoreGroup);
        }
      } else {
        if (currentGroup > 0) {
          state.exceptRestoreGroupById.set(id, currentGroup);
        }

        exceptIds.add(id);
      }

      if (state.tierlist && Number.isFinite(state.x)) {
        renderRows(state.tierlist, state.x);
      }
    }

    function parseControlPayload(el) {
      const id = Number.parseInt(el.dataset.id ?? '', 10);
      const type = el.dataset.type;
      const group = Number.parseInt(el.dataset.group ?? '', 10);

      if (!Number.isInteger(id) || !Number.isInteger(group) || (type !== 'identity' && type !== 'ego')) {
        return null;
      }

      return { id, type, group };
    }

    function onControlClick(event) {
      const moveButton = event.target.closest('button[data-action="move"]');
      if (!moveButton) {
        return;
      }

      const payload = parseControlPayload(moveButton);
      if (!payload) {
        return;
      }

      const delta = Number.parseInt(moveButton.dataset.delta ?? '', 10);
      handleMove(payload.id, payload.type, payload.group, delta);
    }

    function onControlChange(event) {
      const exceptCheckbox = event.target.closest('input[data-action="toggle-except"]');
      if (!exceptCheckbox) {
        return;
      }

      const payload = parseControlPayload(exceptCheckbox);
      if (!payload) {
        return;
      }

      handleExceptToggle(payload.id, payload.type, payload.group, exceptCheckbox.checked);
    }

    bodyIdentityEl.addEventListener('click', onControlClick);
    bodyEgoEl.addEventListener('click', onControlClick);
    bodyIdentityEl.addEventListener('change', onControlChange);
    bodyEgoEl.addEventListener('change', onControlChange);

    function applyAdjustControlVisibility(show) {
      document.body.classList.toggle('hide-adjust-controls', !show);
    }

    if (toggleAdjustControlsInput) {
      toggleAdjustControlsInput.addEventListener('change', () => {
        applyAdjustControlVisibility(toggleAdjustControlsInput.checked);
      });

      applyAdjustControlVisibility(toggleAdjustControlsInput.checked);
    }

    if (toggleExceptRowsInput) {
      toggleExceptRowsInput.addEventListener('change', () => {
        if (state.tierlist && Number.isFinite(state.x)) {
          renderRows(state.tierlist, state.x);
        }
      });
    }

    renderIdRangeFilters();

    if (idRangeFiltersEl) {
      idRangeFiltersEl.addEventListener('change', (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement) || target.dataset.action !== 'toggle-id-range') {
          return;
        }

        if (state.tierlist && Number.isFinite(state.x)) {
          renderRows(state.tierlist, state.x);
        }
      });

      idRangeFiltersEl.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-action]');
        if (!button) {
          return;
        }

        if (button.dataset.action === 'clear-all-ranges') {
          setAllRangeFilters(false);
        }

        if (button.dataset.action === 'check-all-ranges') {
          setAllRangeFilters(true);
        }
      });
    }

    function encodeDiffId(id) {
      const high = Math.floor(id / 1000);
      const low = id % 100;

      if (high > 35 || low > 35) {
        throw new Error(`ID ${id} は圧縮形式の範囲外です（上位・下位とも35以下が必要）`);
      }

      return {
        id,
        high,
        low,
        highChar: high.toString(36),
        lowChar: low.toString(36),
      };
    }

    function compressEncodedIds(ids) {
      const encoded = ids
        .slice()
        .sort((a, b) => a - b)
        .map((id) => encodeDiffId(id));

      let result = '';
      let index = 0;

      while (index < encoded.length) {
        const start = encoded[index];
        let endIndex = index;

        while (
          endIndex + 1 < encoded.length
          && encoded[endIndex + 1].high === start.high
          && encoded[endIndex + 1].low === encoded[endIndex].low + 1
        ) {
          endIndex += 1;
        }

        const runLength = endIndex - index + 1;
        if (runLength >= 3) {
          result += `${start.highChar}${start.lowChar}~${encoded[endIndex].lowChar}`;
          index = endIndex + 1;
          continue;
        }

        for (let i = index; i <= endIndex; i += 1) {
          result += `${encoded[i].highChar}${encoded[i].lowChar}`;
        }

        index = endIndex + 1;
      }

      return result;
    }

    function toBase64Url(input) {
      return btoa(input)
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/g, '');
    }

    function fromBase64Url(input) {
      const normalized = input
        .replace(/-/g, '+')
        .replace(/_/g, '/');

      const padLength = (4 - (normalized.length % 4)) % 4;
      return atob(`${normalized}${'='.repeat(padLength)}`);
    }

    function decodeSection(section) {
      if (!section) {
        return [];
      }

      const ids = [];
      let i = 0;

      while (i < section.length) {
        const highChar = section[i];
        const lowChar = section[i + 1];

        if (!highChar || !lowChar) {
          throw new Error('Cパラメータの形式が不正です（ID桁不足）');
        }

        const high = Number.parseInt(highChar, 36);
        const lowStart = Number.parseInt(lowChar, 36);

        if (!Number.isInteger(high) || !Number.isInteger(lowStart)) {
          throw new Error('Cパラメータの形式が不正です（base36変換失敗）');
        }

        const rangeMark = section[i + 2];
        if (rangeMark === '~') {
          const lowEndChar = section[i + 3];
          const lowEnd = Number.parseInt(lowEndChar ?? '', 36);

          if (!Number.isInteger(lowEnd) || lowEnd < lowStart) {
            throw new Error('Cパラメータの形式が不正です（範囲指定）');
          }

          for (let low = lowStart; low <= lowEnd; low += 1) {
            ids.push(high * 1000 + low);
          }

          i += 4;
          continue;
        }

        ids.push(high * 1000 + lowStart);
        i += 2;
      }

      return ids;
    }

    function applyCompressedDiffParam(cParam) {
      resetDiffState();

      if (!cParam) {
        return;
      }

      const decoded = fromBase64Url(cParam);
      const sections = decoded.split('.');
      if (sections.length !== 10) {
        throw new Error('Cパラメータの形式が不正です（セクション数）');
      }

      for (let sectionIndex = 0; sectionIndex < sections.length; sectionIndex += 1) {
        const group = 9 - sectionIndex;
        const ids = decodeSection(sections[sectionIndex]);

        ids.forEach((id) => {
          if (group === 0) {
            if (belongsToType(id, 'identity')) {
              state.exceptIdentityIds.add(id);
            } else {
              state.exceptEgoIds.add(id);
            }
            return;
          }

          setManualGroupOverride(id, belongsToType(id, 'identity') ? 'identity' : 'ego', group);
        });
      }
    }

    function buildCompressedDiffParam() {
      const idsByGroup = new Map();
      for (let group = 0; group <= 9; group += 1) {
        idsByGroup.set(group, []);
      }

      const exceptAll = new Set([...state.exceptIdentityIds, ...state.exceptEgoIds]);

      state.manualGroupById.forEach((group, id) => {
        if (exceptAll.has(id)) {
          return;
        }

        if (group >= 1 && group <= 9) {
          idsByGroup.get(group).push(id);
        }
      });

      exceptAll.forEach((id) => idsByGroup.get(0).push(id));

      const sections = [];
      for (let group = 9; group >= 0; group -= 1) {
        sections.push(compressEncodedIds(idsByGroup.get(group)));
      }

      return toBase64Url(sections.join('.'));
    }

    function generateShareUrl() {
      if (!state.tierlist || !Number.isFinite(state.x)) {
        return;
      }

      try {
        const compressed = buildCompressedDiffParam();
        const url = `https://394ast.github.io/limbus.tiermaker/?T=${state.tableIndex}&X=${state.x}&C=${compressed}`;

        if (generatedUrlInput) {
          generatedUrlInput.value = url;
          generatedUrlInput.focus();
          generatedUrlInput.select();
        }
      } catch (err) {
        if (generatedUrlInput) {
          generatedUrlInput.value = `URL生成エラー: ${err.message}`;
        }
      }
    }

    function applyCustomSize(width) {
      document.documentElement.style.setProperty('--img-size', `${width}px`);
    }

    imgSizeForm.addEventListener('change', (event) => {
      if (event.target.type !== 'radio') {
        return;
      }

      const selectedSize = event.target.value;
      if (selectedSize === 'custom') {
        const currentSize = Number.parseInt(
          getComputedStyle(document.documentElement).getPropertyValue('--img-size') ?? '',
          10
        );
        customWidthInput.value = Number.isInteger(currentSize) && currentSize > 0 ? currentSize : 80;
        customWidthInput.disabled = false;
        customWidthInput.focus();
        applyCustomSize(Number.parseInt(customWidthInput.value, 10));
        return;
      }

      customWidthInput.value = '';
      customWidthInput.disabled = true;

      if (selectedSize === 'size1') applyCustomSize(60);
      if (selectedSize === 'size2') applyCustomSize(80);
      if (selectedSize === 'size3') applyCustomSize(120);
      if (selectedSize === 'size4') applyCustomSize(200);
    });

    customWidthInput.addEventListener('input', () => {
      const selected = document.querySelector('input[name="imgSize"]:checked');
      if (!selected || selected.value !== 'custom') {
        return;
      }

      let customWidth = Number.parseInt(customWidthInput.value ?? '', 10);
      if (!Number.isInteger(customWidth)) {
        return;
      }

      customWidth = Math.max(20, Math.min(customWidth, 1000));
      setTimeout(() => applyCustomSize(customWidth), 100);
    });

    applyCustomSize(120);

    const DEFAULT_T = 0;
    const DEFAULT_X = 1;

    function getQuerySettings() {
      const params = new URLSearchParams(window.location.search);
      const tableParam = params.get('T');
      const xParam = params.get('X');
      const changeParam = params.get('S');
      const compressedParam = params.get('C');

      state.changeParam = changeParam;

      if (statusEl) {
        statusEl.hidden = !(changeParam !== null && changeParam !== '');
      }

      const tableIndex = Number.parseInt(tableParam ?? String(DEFAULT_T), 10);
      const xValue = xParam !== null ? Number(xParam) : DEFAULT_X;

      return {
        tableIndex: Number.isInteger(tableIndex) && tableIndex >= 0 ? tableIndex : DEFAULT_T,
        xValue,
        compressedParam,
      };
    }

    async function loadAndRender() {
      const { tableIndex, xValue, compressedParam } = getQuerySettings();
      const x = xValue;

      if (!Number.isFinite(x)) {
        statusEl.textContent = 'URLクエリ X は数値で指定してください。例: ?T=0&X=1';
        statusEl.className = 'error';
        return;
      }

      try {
        const response = await fetch(`data/table${tableIndex}.json`, { cache: 'no-store' });
        if (!response.ok) {
          throw new Error(`data/table${tableIndex}.json の取得に失敗しました (HTTP ${response.status})`);
        }

        const tierlist = await response.json();
        state.tierlist = tierlist;
        state.x = x;
        state.tableIndex = tableIndex;
        initializeBaseGroupedData(tierlist, x);
        applyCompressedDiffParam(compressedParam);
        renderRows(tierlist, x);

        statusEl.textContent = `読み込み完了（table${tableIndex} / 件数: ${tierlist.length} / X: ${x}）`;
        statusEl.className = '';

      } catch (err) {
        statusEl.textContent = `エラー: ${err.message}`;
        statusEl.className = 'error';
        bodyIdentityEl.innerHTML = '';
        bodyEgoEl.innerHTML = '';
        state.baseGroupedByType.identity = null;
        state.baseGroupedByType.ego = null;
        state.baseGroupedSnapshot.tierlist = null;
        state.baseGroupedSnapshot.x = null;
      }
    }

    syncModeInputs.forEach((input) => {
      input.addEventListener('change', () => {
        if (state.tierlist && Number.isFinite(state.x)) {
          renderRows(state.tierlist, state.x);
        }
      });
    });

    if (generateUrlButton) {
      generateUrlButton.addEventListener('click', generateShareUrl);
    }

    loadAndRender();
  </script>
</body>
</html>
